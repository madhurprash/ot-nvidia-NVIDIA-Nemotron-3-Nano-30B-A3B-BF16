{
    "results": {
        "tool": {
            "name": "pytest",
            "version": "8.4.1"
        },
        "summary": {
            "tests": 5,
            "passed": 3,
            "failed": 2,
            "skipped": 0,
            "pending": 0,
            "other": 0,
            "start": 1768184045.8779154,
            "stop": 1768184056.8039865
        },
        "tests": [
            {
                "name": "test_outputs.py::test_apply_macros_exists",
                "status": "passed",
                "duration": 0.00048417801735922694,
                "start": 1768184045.9681382,
                "stop": 1768184045.9688377,
                "retries": 0,
                "file_path": "test_outputs.py"
            },
            {
                "name": "test_outputs.py::test_apply_macros_well_formed",
                "status": "failed",
                "raw_status": "call_failed",
                "duration": 0.000801342015620321,
                "start": 1768184045.9690409,
                "stop": 1768184045.985543,
                "retries": 0,
                "file_path": "test_outputs.py",
                "trace": "def test_apply_macros_well_formed():\n        \"\"\"\n        Ensure the Vim macros script is well-formed and includes required commands and\n        only valid commands.\n        \"\"\"\n        text = APPLY_SCRIPT.read_text(encoding=\"utf-8\", errors=\"ignore\")\n        # Parse the script content\n        lines = [\n            line.strip()\n            for line in text.split(\"\\n\")\n            if line.strip() and not line.strip().startswith('\"')\n        ]\n        # Any use of :%normal! must be exactly with @a/@b/@c\n        other_normals = re.findall(r\"^\\s*:%normal!\\s+(\\S+)\", text, re.MULTILINE)\n        assert all(tok in (\"@a\", \"@b\", \"@c\") for tok in other_normals), (\n            f\"Only @a/@b/@c may be used with :%normal!, found: {other_normals}\"\n        )\n        # Check for required components\n        has_exit = any(line in (\":wq\", \":x\") for line in lines)\n        # Check for setreg calls for all three registers (flexible quote matching)\n        setreg_a = any(re.search(r\"call setreg\\(['\\\"]a['\\\"],\", line) for line in lines)\n        setreg_b = any(re.search(r\"call setreg\\(['\\\"]b['\\\"],\", line) for line in lines)\n        setreg_c = any(re.search(r\"call setreg\\(['\\\"]c['\\\"],\", line) for line in lines)\n        # Check for macro execution calls for all three registers\n        exec_a = any(\":%normal! @a\" in line for line in lines)\n        exec_b = any(\":%normal! @b\" in line for line in lines)\n        exec_c = any(\":%normal! @c\" in line for line in lines)\n        # Validate required components\n        assert has_exit, \"Missing :wq or :x\"\n        assert (setreg_a and setreg_b and setreg_c), \"Must define all 3 macros\"\n>       assert (exec_a and exec_b and exec_c), \"Must execute all 3 macros\"\nE       AssertionError: Must execute all 3 macros\nE       assert (False)\n\n/tests/test_outputs.py:158: AssertionError",
                "message": "The test failed in the call phase due to an assertion error"
            },
            {
                "name": "test_outputs.py::test_apply_macros_runs",
                "status": "passed",
                "duration": 10.621901255042758,
                "start": 1768184045.9857323,
                "stop": 1768184056.6078517,
                "retries": 0,
                "file_path": "test_outputs.py"
            },
            {
                "name": "test_outputs.py::test_input_equiv_expected",
                "status": "failed",
                "raw_status": "call_failed",
                "duration": 0.18204106896882877,
                "start": 1768184056.6081097,
                "stop": 1768184056.7954955,
                "retries": 0,
                "file_path": "test_outputs.py",
                "trace": "def test_input_equiv_expected():\n        \"\"\"\n        Compare input.csv and expected.csv (large files) via SHA-256 to avoid loading both\n        entirely into memory multiple times. Ensures byte-for-byte match.\n        \"\"\"\n        assert INPUT.exists(), f\"Missing transformed file: {INPUT}\"\n        assert EXPECTED.exists(), f\"Missing expected file: {EXPECTED}\"\n        got_hash = _sha256(INPUT)\n        exp_hash = _sha256(EXPECTED)\n>       assert got_hash == exp_hash, \"Transformed file does not match expected.\"\nE       AssertionError: Transformed file does not match expected.\nE       assert 'cc6c05c4dedd...3f3e698af68b0' == '833cb9527dad...6eb2935f41f97'\nE         \nE         - 833cb9527dad306efe9f8f870497f6f519e3978e9c27f093bc56eb2935f41f97\nE         + cc6c05c4dedde803e9c95ddc73a9b053aa0f37418af3ee5e5323f3e698af68b0\n\n/tests/test_outputs.py:191: AssertionError",
                "message": "The test failed in the call phase due to an assertion error"
            },
            {
                "name": "test_outputs.py::test_macros_nonempty_and_efficient",
                "status": "passed",
                "duration": 0.007909985026344657,
                "start": 1768184056.7957199,
                "stop": 1768184056.8037837,
                "retries": 0,
                "file_path": "test_outputs.py"
            }
        ]
    }
}