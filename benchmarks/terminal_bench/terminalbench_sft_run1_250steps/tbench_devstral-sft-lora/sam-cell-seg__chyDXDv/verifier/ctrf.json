{
    "results": {
        "tool": {
            "name": "pytest",
            "version": "8.4.1"
        },
        "summary": {
            "tests": 9,
            "passed": 4,
            "failed": 5,
            "skipped": 0,
            "pending": 0,
            "other": 0,
            "start": 1768183606.0755618,
            "stop": 1768183609.9679468
        },
        "tests": [
            {
                "name": "test_outputs.py::test_python_file_exists",
                "status": "passed",
                "duration": 0.0005735390004701912,
                "start": 1768183609.0654268,
                "stop": 1768183609.0662763,
                "retries": 0,
                "file_path": "test_outputs.py"
            },
            {
                "name": "test_outputs.py::test_run_script",
                "status": "passed",
                "duration": 0.7035811539972201,
                "start": 1768183609.0664659,
                "stop": 1768183609.770313,
                "retries": 0,
                "file_path": "test_outputs.py"
            },
            {
                "name": "test_outputs.py::test_csv_output_exists",
                "status": "passed",
                "duration": 0.00043961795745417476,
                "start": 1768183609.7705784,
                "stop": 1768183609.7712061,
                "retries": 0,
                "file_path": "test_outputs.py"
            },
            {
                "name": "test_outputs.py::test_csv_shape_cols",
                "status": "failed",
                "raw_status": "call_failed",
                "duration": 0.028921030985657126,
                "start": 1768183609.7713897,
                "stop": 1768183609.8505223,
                "retries": 0,
                "file_path": "test_outputs.py",
                "trace": "def test_csv_shape_cols():\n        '''Check if the output CSV file has the correct shape and columns.'''\n        import pandas as pd\n    \n        out_df = pd.read_csv(\"/app/test_output.csv\")\n        correct_df = pd.read_csv(\"correct_output.csv\")\n    \n        # Check number of rows (should match input CSV)\n>       assert out_df.shape == correct_df.shape, (f\"Output df shape is incorrect,  \"\n                                                  f\"got {out_df.shape},\"\n                                                  f\" expected {correct_df.shape}\")\nE       AssertionError: Output df shape is incorrect,  got (32, 10), expected (32, 11)\nE       assert (32, 10) == (32, 11)\nE         \nE         At index 1 diff: 10 != 11\nE         Use -v to get more diff\n\n/tests/test_outputs.py:190: AssertionError",
                "message": "The test failed in the call phase due to an assertion error"
            },
            {
                "name": "test_outputs.py::test_masks_are_no_longer_rect",
                "status": "failed",
                "raw_status": "call_failed",
                "duration": 0.010491490073036402,
                "start": 1768183609.8507152,
                "stop": 1768183609.865331,
                "retries": 0,
                "file_path": "test_outputs.py",
                "trace": "def test_masks_are_no_longer_rect():\n        \"\"\"\n        Given a DataFrame, asserts that the resulting polyline is not a rectangle.\n        \"\"\"\n        df = _read_polylines_csv(\"/app/test_output.csv\")\n        # Extract points into a list of (x, y) tuples\n        for _, row in df.iterrows():\n            points = list(zip(row['coords_x'], row['coords_y']))\n            # Assert that the shape is NOT a rectangle\n>           assert not is_rectangle_shapely(\n                points), \"The polyline was incorrectly identified as a rectangle.\"\nE           AssertionError: The polyline was incorrectly identified as a rectangle.\nE           assert not np.True_\nE            +  where np.True_ = is_rectangle_shapely([(263, 192), (266, 192), (269, 192), (272, 192), (275, 192), (278, 192), ...])\n\n/tests/test_outputs.py:209: AssertionError",
                "message": "The test failed in the call phase due to an assertion error"
            },
            {
                "name": "test_outputs.py::test_mask_alignment",
                "status": "failed",
                "raw_status": "call_failed",
                "duration": 0.03476231801323593,
                "start": 1768183609.8655047,
                "stop": 1768183609.9046407,
                "retries": 0,
                "file_path": "test_outputs.py",
                "trace": "def test_mask_alignment():\n        '''Test that the predicted masks align reasonably with the masks generated\n         by solution.sh '''\n        out_df = _read_polylines_csv(\"/app/test_output.csv\")\n        correct_df = _read_polylines_csv(\"/app/correct_output.csv\")\n        for (_, row_out), (_, row_correct) in zip(out_df.iterrows(), correct_df.iterrows()):\n            points_out = list(zip(row_out['coords_x'], row_out['coords_y']))\n            points_correct = list(zip(row_correct['coords_x'], row_correct['coords_y']))\n            iou = calculate_iou(np.array(points_out), np.array(points_correct))\n>           assert iou >= 0.5, f\"IoU is too low: {iou}\"\nE           AssertionError: IoU is too low: 0.49142857142857144\nE           assert 0.49142857142857144 >= 0.5\n\n/tests/test_outputs.py:221: AssertionError",
                "message": "The test failed in the call phase due to an assertion error"
            },
            {
                "name": "test_outputs.py::test_no_polyline_overlaps",
                "status": "failed",
                "raw_status": "call_failed",
                "duration": 0.012087862996850163,
                "start": 1768183609.9048307,
                "stop": 1768183609.9217298,
                "retries": 0,
                "file_path": "test_outputs.py",
                "trace": "def test_no_polyline_overlaps():\n        \"\"\"\n        Checks that there are no significant overlaps between any of the predicted masks.\n        \"\"\"\n        df = _read_polylines_csv(\"/app/test_output.csv\")\n        polygons = []\n        for index, row in df.iterrows():\n            points = list(zip(row['coords_x'], row['coords_y']))\n            poly = _as_polygon(points)\n            if poly:\n                polygons.append(poly)\n    \n        # Check for overlaps between all pairs of polygons\n        for poly1, poly2 in itertools.combinations(polygons, 2):\n            if poly1.intersects(poly2):\n                intersection_area = poly1.intersection(poly2).area\n                # Fail if intersection area is more than a tiny fraction of either polygon's\n                # area this avoids failures due to simple touching boundaries\n                assert intersection_area / poly1.area < 1e-3, (\"Polygons \"\n                                                               \"overlap significantly\")\n>               assert intersection_area / poly2.area < 1e-3, (\"Polygons \"\n                                                               \"overlap significantly\")\nE               AssertionError: Polygons overlap significantly\nE               assert (2.426373626373606 / 1960.5) < 0.001\nE                +  where 1960.5 = <POLYGON ((256 44, 256 35, 262 28, 280 7, 285 2, 289 0, 295 0, 304 2, 306 4,...>.area\n\n/tests/test_outputs.py:243: AssertionError",
                "message": "The test failed in the call phase due to an assertion error"
            },
            {
                "name": "test_outputs.py::test_single_contiguous_mask_per_cell",
                "status": "passed",
                "duration": 0.039048535050824285,
                "start": 1768183609.921932,
                "stop": 1768183609.9611537,
                "retries": 0,
                "file_path": "test_outputs.py"
            },
            {
                "name": "test_outputs.py::test_coords_are_flat_lists",
                "status": "failed",
                "raw_status": "call_failed",
                "duration": 0.0016711270436644554,
                "start": 1768183609.9613502,
                "stop": 1768183609.9677663,
                "retries": 0,
                "file_path": "test_outputs.py",
                "trace": "def test_coords_are_flat_lists():\n        \"\"\"\n        Checks that 'coords_x' and 'coords_y' columns contain flat lists of numbers,\n        allowing for them to be stored as strings.\n        \"\"\"\n        df = pd.read_csv(\"/app/test_output.csv\")\n        for col in ['coords_x', 'coords_y']:\n            for index, value in df[col].items():\n                parsed_value = None\n                if isinstance(value, str):\n                    try:\n                        # Use ast.literal_eval for safe evaluation of string\n                        parsed_value = ast.literal_eval(value)\n                    except (ValueError, SyntaxError):\n                        assert False, (f\"Row {index}, column '{col}': \"\n                                       f\"could not parse string.\")\n                elif isinstance(value, (list, np.ndarray)):\n                    parsed_value = value\n                else:\n                    assert False, (f\"Row {index}, column '{col}': value is\"\n                                   f\" not a list or string (got {type(value)}).\")\n    \n>               assert isinstance(parsed_value, list), \\\n                    (f\"Row {index}, column '{col}': parsed value is \"\n                     f\"not a list (got {type(parsed_value)}).\")\nE               AssertionError: Row 0, column 'coords_x': parsed value is not a list (got <class 'tuple'>).\nE               assert False\nE                +  where False = isinstance((72.0, 76.0, 79.0, 84.0, 91.0, 96.0, ...), list)\n\n/tests/test_outputs.py:280: AssertionError",
                "message": "The test failed in the call phase due to an assertion error"
            }
        ]
    }
}